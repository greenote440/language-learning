import { useEffect, useState, useRef } from "react";
import MainListeningScreen from "@/components/MainListeningScreen";
import { useContentGeneration } from "@/hooks/useContentGeneration";
import { useSession } from "@/contexts/SessionContext";
import { useContent } from "@/contexts/ContentContext";
import { useAudioPlayer } from "@/contexts/AudioPlayerContext";
import { loadPreferences } from "@/utils/preferences";
import { AlertCircle } from "lucide-react";

const Index = () => {
  const session = useSession();
  const contentContext = useContent();
  const audioPlayer = useAudioPlayer();
  const [autoGenerationAttempted, setAutoGenerationAttempted] = useState(false);
  const [generationError, setGenerationError] = useState<string | null>(null);
  const hasAutoGeneratedRef = useRef(false);

  const { generate, isGenerating, error: generationErrorObj } = useContentGeneration({
    onSuccess: (content) => {
      console.log('Content generated successfully:', content.id);
      setGenerationError(null);
      
      // Auto-play will be handled by AudioPlayerContext when content is loaded
      // Attempt auto-play after a short delay to ensure audio is loaded
      setTimeout(() => {
        tryAutoPlay();
      }, 500);
    },
    onError: (error) => {
      console.error('Content generation failed:', error);
      setGenerationError(error.message || 'Failed to generate content');
    },
  });

  // Attempt auto-play with browser policy handling
  const tryAutoPlay = async () => {
    if (!audioPlayer.state.currentContent) return;

    try {
      await audioPlayer.play();
    } catch (error) {
      // Browser blocked auto-play - this is expected and handled by AudioPlayer component
      console.log('Auto-play blocked by browser policy (expected behavior)');
    }
  };

  // Auto-generate content on initial app load
  useEffect(() => {
    // Only trigger on initial load, not on navigation
    if (hasAutoGeneratedRef.current) return;
    
    // Check if session already has content AND it's loaded in ContentContext
    if (session.contentIds.length > 0) {
      // Verify that at least one content item actually exists in ContentContext
      const hasLoadedContent = session.contentIds.some(
        (contentId) => contentContext.getContent(contentId) !== undefined
      );
      
      if (hasLoadedContent) {
        console.log('Session already has content, skipping auto-generation');
        hasAutoGeneratedRef.current = true;
        return;
      } else {
        // Session has IDs but content isn't loaded - this shouldn't happen with persistence
        // but if it does, clear the session and generate new content
        console.log('Session has content IDs but content not loaded, generating new content');
        // Clear invalid session data
        session.contentIds.forEach(() => {
          // Content will be regenerated
        });
      }
    }

    // Trigger auto-generation within 2 seconds of app load
    const timeoutId = setTimeout(() => {
      if (hasAutoGeneratedRef.current) return;
      
      hasAutoGeneratedRef.current = true;
      setAutoGenerationAttempted(true);
      
      // Load user preferences
      const preferences = loadPreferences();
      
      // Generate content with default format (will be randomized if not specified)
      generate(preferences).catch((err) => {
        console.error('Failed to trigger auto-generation:', err);
        setGenerationError(err.message || 'Failed to start content generation');
      });
    }, 100); // Start generation quickly (within 100ms, well under 2 seconds)

    return () => {
      clearTimeout(timeoutId);
    };
  }, [session.contentIds.length, contentContext, generate]);

  const handleLike = (clipId: string, liked: boolean) => {
    console.log(`Episode ${clipId} ${liked ? 'liked' : 'unliked'}`);
  };

  const handleComprehension = (clipId: string, percentage: number) => {
    console.log(`Episode ${clipId} comprehension: ${percentage}%`);
  };

  const handleContentChange = (direction: 'forward' | 'backward') => {
    console.log(`Content change requested: ${direction}`);
  };

  const handleRetryGeneration = () => {
    setGenerationError(null);
    hasAutoGeneratedRef.current = false;
    setAutoGenerationAttempted(false);
    
    const preferences = loadPreferences();
    generate(preferences).catch((err) => {
      console.error('Failed to retry generation:', err);
      setGenerationError(err.message || 'Failed to start content generation');
    });
  };

  return (
    <div className="relative">
      {/* Error Message Overlay */}
      {generationError && (
        <div className="fixed top-4 left-1/2 -translate-x-1/2 z-50 max-w-md w-full mx-4">
          <div className="bg-destructive/10 border border-destructive/20 rounded-lg p-4 flex items-start gap-3">
            <AlertCircle className="w-5 h-5 text-destructive flex-shrink-0 mt-0.5" />
            <div className="flex-1">
              <p className="text-sm font-medium text-destructive mb-1">
                Errore di generazione
              </p>
              <p className="text-sm text-destructive/80 mb-3">
                {generationError}
              </p>
              <button
                onClick={handleRetryGeneration}
                className="text-sm font-medium text-destructive hover:underline"
              >
                Riprova
              </button>
            </div>
          </div>
        </div>
      )}

      {/* Loading Overlay during initial generation */}
      {isGenerating && autoGenerationAttempted && session.contentIds.length === 0 && (
        <div className="fixed inset-0 bg-background/80 backdrop-blur-sm flex items-center justify-center z-40">
          <div className="flex flex-col items-center gap-4">
            <div className="w-12 h-12 border-3 border-primary border-t-transparent rounded-full animate-spin" />
            <span className="text-muted-foreground text-sm">Generando contenuto...</span>
          </div>
        </div>
      )}

      <MainListeningScreen
        onLike={handleLike}
        onComprehensionReport={handleComprehension}
        onContentChange={handleContentChange}
      />
    </div>
  );
};

export default Index;
