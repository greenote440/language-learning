import { useEffect, useState, useRef } from "react";
import MainListeningScreen from "@/components/MainListeningScreen";
import { useContentGeneration } from "@/hooks/useContentGeneration";
import { useSession } from "@/contexts/SessionContext";
import { useAudioPlayer } from "@/contexts/AudioPlayerContext";
import { useContent } from "@/contexts/ContentContext";
import { loadPreferences } from "@/utils/preferences";
import { AlertCircle } from "lucide-react";
import { mockContentService } from "@/services/mockContentService";

const USE_MOCK_DATA = import.meta.env.VITE_USE_MOCK_DATA === 'true' || !import.meta.env.VITE_API_BASE_URL;

const Index = () => {
  const session = useSession();
  const audioPlayer = useAudioPlayer();
  const contentContext = useContent();
  const [autoGenerationAttempted, setAutoGenerationAttempted] = useState(false);
  const [generationError, setGenerationError] = useState<string | null>(null);
  const [isInitialized, setIsInitialized] = useState(false);
  const hasAutoGeneratedRef = useRef(false);
  const hasInitializedMockRef = useRef(false);

  const { generate, isGenerating, error: generationErrorObj } = useContentGeneration({
    onSuccess: (content) => {
      console.log('Content generated successfully:', content.id);
      setGenerationError(null);
      
      // Auto-play will be handled by AudioPlayerContext when content is loaded
      // Attempt auto-play after a short delay to ensure audio is loaded
      setTimeout(() => {
        tryAutoPlay();
      }, 500);
    },
    onError: (error) => {
      console.error('Content generation failed:', error);
      setGenerationError(error.message || 'Failed to generate content');
    },
  });

  // Attempt auto-play with browser policy handling
  const tryAutoPlay = async () => {
    if (!audioPlayer.state.currentContent) return;

    try {
      await audioPlayer.play();
    } catch (error) {
      // Browser blocked auto-play - this is expected and handled by AudioPlayer component
      console.log('Auto-play blocked by browser policy (expected behavior)');
    }
  };

  // Initialize with mock content if in mock mode
  useEffect(() => {
    if (hasInitializedMockRef.current || isInitialized) {
      return;
    }
    
    // Check if we already have content (from localStorage or previous session)
    if (session.contentIds.length > 0) {
      console.log('Session already has content, skipping mock initialization');
      hasInitializedMockRef.current = true;
      setIsInitialized(true);
      return;
    }
    
    console.log('Initializing mock content...');
    hasInitializedMockRef.current = true;
    
    // Load initial mock content
    const mockContent = mockContentService.getInitialMockContent();
    console.log('Loaded mock content:', mockContent.length, 'items');
    
    if (mockContent.length === 0) {
      console.error('No mock content available!');
      return;
    }
    
    // Convert all content to context format
    const contextContents = mockContent.map((content) => ({
      id: content.id,
      title: content.title,
      subtitle: content.description,
      audioUrl: content.audioUrl,
      duration: content.duration,
      format: content.format,
    }));
    
    // Add all content to contexts
    contextContents.forEach((contextContent) => {
      contentContext.addContent(contextContent);
      session.addContentId(contextContent.id);
      console.log('Added content:', contextContent.id, contextContent.title);
    });
    
    // Set first content as current
    if (contextContents.length > 0) {
      const firstContent = contextContents[0];
      session.setCurrentContentId(firstContent.id);
      audioPlayer.loadContent(firstContent);
      console.log('Set current content:', firstContent.id);
    }
    
    // Mark as initialized after state updates
    setTimeout(() => {
      setIsInitialized(true);
      console.log('Initialization complete. Session has', session.contentIds.length, 'items');
      console.log('ContentContext has', contentContext.content.length, 'items');
    }, 50);
  }, [session, contentContext, audioPlayer, isInitialized]);

  // Auto-generate content on initial app load (only if not using mock data or if mock data is empty)
  useEffect(() => {
    // Only trigger on initial load, not on navigation
    if (hasAutoGeneratedRef.current) return;
    
    // Check if session already has content (don't auto-generate if content exists)
    if (session.contentIds.length > 0) {
      console.log('Session already has content, skipping auto-generation');
      hasAutoGeneratedRef.current = true;
      return;
    }

    // In mock mode, content is initialized separately
    if (USE_MOCK_DATA) {
      hasAutoGeneratedRef.current = true;
      return;
    }

    // Trigger auto-generation within 2 seconds of app load
    const timeoutId = setTimeout(() => {
      if (hasAutoGeneratedRef.current) return;
      
      hasAutoGeneratedRef.current = true;
      setAutoGenerationAttempted(true);
      
      // Load user preferences
      const preferences = loadPreferences();
      
      // Generate content with default format (will be randomized if not specified)
      generate(preferences).catch((err) => {
        console.error('Failed to trigger auto-generation:', err);
        setGenerationError(err.message || 'Failed to start content generation');
      });
    }, 100); // Start generation quickly (within 100ms, well under 2 seconds)

    return () => {
      clearTimeout(timeoutId);
    };
  }, [session.contentIds.length, generate, USE_MOCK_DATA]);

  const handleLike = (clipId: string, liked: boolean) => {
    console.log(`Episode ${clipId} ${liked ? 'liked' : 'unliked'}`);
  };

  const handleComprehension = (clipId: string, percentage: number) => {
    console.log(`Episode ${clipId} comprehension: ${percentage}%`);
  };

  const handleContentChange = (direction: 'forward' | 'backward') => {
    console.log(`Content change requested: ${direction}`);
  };

  const handleRetryGeneration = () => {
    setGenerationError(null);
    hasAutoGeneratedRef.current = false;
    setAutoGenerationAttempted(false);
    
    const preferences = loadPreferences();
    generate(preferences).catch((err) => {
      console.error('Failed to retry generation:', err);
      setGenerationError(err.message || 'Failed to start content generation');
    });
  };

  return (
    <div className="relative">
      {/* Error Message Overlay */}
      {generationError && (
        <div className="fixed top-4 left-1/2 -translate-x-1/2 z-50 max-w-md w-full mx-4">
          <div className="bg-destructive/10 border border-destructive/20 rounded-lg p-4 flex items-start gap-3">
            <AlertCircle className="w-5 h-5 text-destructive flex-shrink-0 mt-0.5" />
            <div className="flex-1">
              <p className="text-sm font-medium text-destructive mb-1">
                Errore di generazione
              </p>
              <p className="text-sm text-destructive/80 mb-3">
                {generationError}
              </p>
              <button
                onClick={handleRetryGeneration}
                className="text-sm font-medium text-destructive hover:underline"
              >
                Riprova
              </button>
            </div>
          </div>
        </div>
      )}

      {/* Loading Overlay during initial generation */}
      {isGenerating && autoGenerationAttempted && session.contentIds.length === 0 && (
        <div className="fixed inset-0 bg-background/80 backdrop-blur-sm flex items-center justify-center z-40">
          <div className="flex flex-col items-center gap-4">
            <div className="w-12 h-12 border-3 border-primary border-t-transparent rounded-full animate-spin" />
            <span className="text-muted-foreground text-sm">Generando contenuto...</span>
          </div>
        </div>
      )}

      <MainListeningScreen
        onLike={handleLike}
        onComprehensionReport={handleComprehension}
        onContentChange={handleContentChange}
      />
    </div>
  );
};

export default Index;
