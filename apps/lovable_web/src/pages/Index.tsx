import { useEffect, useState, useRef } from "react";
import MainListeningScreen from "@/components/MainListeningScreen";
import { useContentGeneration } from "@/hooks/useContentGeneration";
import { useSession } from "@/contexts/SessionContext";
import { useAudioPlayer } from "@/contexts/AudioPlayerContext";
import { useContent } from "@/contexts/ContentContext";
import { loadPreferences } from "@/utils/preferences";
import { cleanupMockData } from "@/utils/storageCleanup";
import { AlertCircle } from "lucide-react";

const Index = () => {
  const session = useSession();
  const audioPlayer = useAudioPlayer();
  const contentContext = useContent();
  const [autoGenerationAttempted, setAutoGenerationAttempted] = useState(false);
  const [generationError, setGenerationError] = useState<string | null>(null);
  const [isInitialized, setIsInitialized] = useState(false);
  const hasAutoGeneratedRef = useRef(false);
  const hasCleanedUpRef = useRef(false);

  // Clean up mock data on mount - run before session loads
  useEffect(() => {
    if (!hasCleanedUpRef.current && typeof window !== 'undefined') {
      // Force cleanup of mock data
      cleanupMockData();
      
      // Also directly fix currentContentId if it's a mock ID
      const STORAGE_KEY = 'italian-audio-session';
      try {
        const stored = localStorage.getItem(STORAGE_KEY);
        if (stored) {
          const data = JSON.parse(stored);
          if (data.currentContentId && data.currentContentId.startsWith('mock-')) {
            console.log('Fixing mock currentContentId in localStorage');
            const validContentIds = (data.contentIds || []).filter((id: string) => !id.startsWith('mock-'));
            const cleanedData = {
              ...data,
              contentIds: validContentIds,
              currentContentId: validContentIds.length > 0 ? validContentIds[0] : null,
            };
            localStorage.setItem(STORAGE_KEY, JSON.stringify(cleanedData));
            // Reload session
            session.loadFromStorage();
          }
        }
      } catch (error) {
        console.error('Failed to cleanup mock data:', error);
      }
      
      hasCleanedUpRef.current = true;
    }
  }, [session]);

  const { generate, isGenerating, error: generationErrorObj } = useContentGeneration({
    onSuccess: (content) => {
      console.log('Content generated successfully:', content.id);
      setGenerationError(null);
      
      // Auto-play will be handled by AudioPlayerContext when content is loaded
      // Attempt auto-play after a short delay to ensure audio is loaded
      setTimeout(() => {
        tryAutoPlay();
      }, 500);
    },
    onError: (error) => {
      console.error('Content generation failed:', error);
      setGenerationError(error.message || 'Failed to generate content');
    },
  });

  // Attempt auto-play with browser policy handling
  const tryAutoPlay = async () => {
    if (!audioPlayer.state.currentContent) return;

    try {
      await audioPlayer.play();
    } catch (error) {
      // Browser blocked auto-play - this is expected and handled by AudioPlayer component
      console.log('Auto-play blocked by browser policy (expected behavior)');
    }
  };


  // Load existing content from API when session has IDs but ContentContext is empty
  useEffect(() => {
    console.log('[Index] Load existing content effect triggered', {
      isInitialized,
      sessionContentIdsLength: session.contentIds.length,
      contentContextLength: contentContext.content.length,
      sessionContentIds: session.contentIds,
    });

    if (isInitialized) {
      console.log('[Index] Already initialized, skipping load');
      return;
    }
    
    if (session.contentIds.length === 0) {
      console.log('[Index] No content IDs in session, marking as initialized');
      setIsInitialized(true);
      return;
    }
    
    if (contentContext.content.length > 0) {
      console.log('[Index] Content already loaded in context, marking as initialized');
      setIsInitialized(true);
      return;
    }

    // Try to load content from API for existing session IDs
    const loadExistingContent = async () => {
      console.log('[Index] Starting to load existing content from API...');
      let loadedCount = 0;
      const validContentIds = session.contentIds.filter(id => !id.startsWith('mock-'));
      
      console.log('[Index] Valid content IDs to load:', validContentIds);
      
      if (validContentIds.length === 0) {
        console.log('[Index] No valid content IDs to load (all are mock IDs)');
        setIsInitialized(true);
        return;
      }
      
      for (const contentId of validContentIds) {
        console.log(`[Index] Attempting to load content: ${contentId}`);
        try {
          const content = await contentContext.loadContent(contentId);
          console.log(`[Index] Load result for ${contentId}:`, content ? 'SUCCESS' : 'NULL (404 or not found)', content);
          if (content) {
            loadedCount++;
            console.log(`[Index] Successfully loaded content ${contentId}, total loaded: ${loadedCount}`);
          } else {
            console.warn(`[Index] loadContent returned null for ${contentId} - content doesn't exist (old/invalid ID)`);
          }
        } catch (error) {
          console.error(`[Index] Exception loading content ${contentId}:`, error);
          // If it's a connection error, the API server might not be running
          if (error instanceof TypeError && error.message.includes('fetch')) {
            console.error(`[Index] Network error for ${contentId}, API server might not be running`);
            setGenerationError('API server is not running. Please start the backend server.');
          }
        }
      }
      
      console.log(`[Index] Finished loading attempt. Loaded: ${loadedCount}/${validContentIds.length} content items`);

      if (loadedCount > 0) {
        console.log(`Loaded ${loadedCount} content items from API`);
        // Set current content if available
        if (session.currentContentId && !session.currentContentId.startsWith('mock-')) {
          const currentContent = contentContext.getContent(session.currentContentId);
          if (currentContent && currentContent.audioUrl) {
            audioPlayer.loadContent({
              ...currentContent,
              audioUrl: currentContent.audioUrl,
            });
          } else if (contentContext.content.length > 0) {
            // Use first loaded content if current isn't available
            const firstContent = contentContext.content[0];
            if (firstContent.audioUrl) {
              audioPlayer.loadContent({
                ...firstContent,
                audioUrl: firstContent.audioUrl,
              });
              session.setCurrentContentId(firstContent.id);
            }
          }
        } else if (contentContext.content.length > 0) {
          // Set first content as current if no current is set
          const firstContent = contentContext.content[0];
          if (firstContent.audioUrl) {
            audioPlayer.loadContent({
              ...firstContent,
              audioUrl: firstContent.audioUrl,
            });
            session.setCurrentContentId(firstContent.id);
          }
        }
      } else if (validContentIds.length > 0) {
        // If we have IDs but couldn't load any content, they're probably invalid/old
        // Clear the session and trigger new generation
        console.log(`[Index] Could not load any content from API (0/${validContentIds.length} loaded). Clearing old session data and triggering new generation.`);
        session.clearSession();
        // Reset initialization state to allow auto-generation
        setIsInitialized(true); // Mark as initialized so auto-gen can run
        hasAutoGeneratedRef.current = false; // Allow auto-generation to trigger
        return;
      } else {
        console.log('[Index] No valid content IDs to load');
      }
      
      setIsInitialized(true);
    };

    loadExistingContent();
  }, [session, contentContext, audioPlayer, isInitialized]);

  // Auto-generate content on initial app load
  useEffect(() => {
    
    // Only trigger on initial load, not on navigation
    if (hasAutoGeneratedRef.current) {
      return;
    }
    
    // Wait for initialization to complete
    if (!isInitialized) {
      return;
    }
    
    // Check if session already has valid content (don't auto-generate if content exists)
    const validContentIds = session.contentIds.filter(id => !id.startsWith('mock-'));
    if (validContentIds.length > 0 && contentContext.content.length > 0) {
      console.log('Session already has content, skipping auto-generation');
      hasAutoGeneratedRef.current = true;
      return;
    }

    // If we have IDs but no content loaded, don't auto-generate (let loadExistingContent handle it)
    if (validContentIds.length > 0) {
      hasAutoGeneratedRef.current = true;
      return;
    }

    
    // Trigger auto-generation within 2 seconds of app load
    const timeoutId = setTimeout(() => {
      if (hasAutoGeneratedRef.current) return;
      
      hasAutoGeneratedRef.current = true;
      setAutoGenerationAttempted(true);
      
      
      // Load user preferences
      const preferences = loadPreferences();
      
      // Generate content with default format (will be randomized if not specified)
      generate(preferences).catch((err) => {
        console.error('Failed to trigger auto-generation:', err);
        setGenerationError(err.message || 'Failed to start content generation');
      });
    }, 100); // Start generation quickly (within 100ms, well under 2 seconds)

    return () => {
      clearTimeout(timeoutId);
    };
  }, [session.contentIds.length, generate, isInitialized]);

  const handleLike = (clipId: string, liked: boolean) => {
    console.log(`Episode ${clipId} ${liked ? 'liked' : 'unliked'}`);
  };

  const handleComprehension = (clipId: string, percentage: number) => {
    console.log(`Episode ${clipId} comprehension: ${percentage}%`);
  };

  const handleContentChange = (direction: 'forward' | 'backward') => {
    console.log(`Content change requested: ${direction}`);
  };

  const handleRetryGeneration = () => {
    setGenerationError(null);
    hasAutoGeneratedRef.current = false;
    setAutoGenerationAttempted(false);
    
    const preferences = loadPreferences();
    generate(preferences).catch((err) => {
      console.error('Failed to retry generation:', err);
      setGenerationError(err.message || 'Failed to start content generation');
    });
  };

  return (
    <div className="relative">
      {/* Error Message Overlay */}
      {generationError && (
        <div className="fixed top-4 left-1/2 -translate-x-1/2 z-50 max-w-md w-full mx-4">
          <div className="bg-destructive/10 border border-destructive/20 rounded-lg p-4 flex items-start gap-3">
            <AlertCircle className="w-5 h-5 text-destructive flex-shrink-0 mt-0.5" />
            <div className="flex-1">
              <p className="text-sm font-medium text-destructive mb-1">
                Errore di generazione
              </p>
              <p className="text-sm text-destructive/80 mb-3">
                {generationError}
              </p>
              <button
                onClick={handleRetryGeneration}
                className="text-sm font-medium text-destructive hover:underline"
              >
                Riprova
              </button>
            </div>
          </div>
        </div>
      )}

      {/* Loading Overlay during initial generation */}
      {isGenerating && autoGenerationAttempted && session.contentIds.length === 0 && (
        <div className="fixed inset-0 bg-background/80 backdrop-blur-sm flex items-center justify-center z-40">
          <div className="flex flex-col items-center gap-4">
            <div className="w-12 h-12 border-3 border-primary border-t-transparent rounded-full animate-spin" />
            <span className="text-muted-foreground text-sm">Generando contenuto...</span>
          </div>
        </div>
      )}

      <MainListeningScreen
        onLike={handleLike}
        onComprehensionReport={handleComprehension}
        onContentChange={handleContentChange}
      />
    </div>
  );
};

export default Index;
