# Story 2.3: Model-Driven AI Text Generation Service

## Status
Done

## Story

**As a** system,  
**I want** to integrate AI text generation APIs with the model service to produce model-driven Italian content on-demand,  
**so that** I can generate diverse, engaging Italian narratives, podcasts, and educational content fresh for each scroll action according to model principles.

## Acceptance Criteria

1. Gemini API (or alternative) integrated into backend service with API key management
2. Content generation service integrates with model service to receive model-driven generation parameters
3. Content generation prompts engineered according to model principles (meaning-first approach, meaning anchoring, controlled variation)
4. Model service determines generation parameters for each request (lexical novelty budget, construction sets, variation patterns, difficulty calibration)
5. Content generation service accepts model-driven parameters and user preferences (difficulty level, format preferences from localStorage)
6. API rate limiting and quota management implemented (respects free-tier limits, handles rate limit errors gracefully)
7. Content generation prompts configured for Italian language output with model-informed structure
8. Support for multiple content format templates (narrative/story, podcast-style, educational/explanatory) with model-driven format selection
9. Generated Italian text follows model principles (meaning-first, comprehensible before correct, appropriate variation, semantic grounding)
10. Generated Italian text is grammatically correct and coherent
11. Content generation completes within 5-10 seconds (non-blocking, runs asynchronously)
12. Content generation service returns structured data (text content, metadata, format type, difficulty level, estimated duration, generation timestamp, model parameters used)
13. Error handling for API failures (network errors, API errors, timeout errors) with appropriate fallback or user feedback
14. Generated content is validated for basic quality (non-empty, minimum length, Italian language detected, model criteria met)
15. Content generation works on-demand (generates fresh content each time according to model specifications, not from pre-existing pool)

## Tasks / Subtasks

- [x] Task 1: Create Content Generation Service Structure (AC: 1, 2)
  - [x] Create `apps/api/src/services/contentGeneration.service.ts` [Source: docs/architecture/unified-project-structure.md]
  - [x] Import and integrate Gemini API client from Story 2.2 (`geminiClient.service.ts`) [Source: Story 2.2]
  - [x] Import ModelService from `@adaptive-italian-audio/model-service` package [Source: Story 2.1]
  - [x] Create service class with methods for content generation [Source: Story AC 1, 2]
  - [x] Ensure service uses API integration service layer for consistent error handling [Source: Story 2.2]
  - [x] Set up service to accept user preferences and session context [Source: Story AC 5]

- [x] Task 2: Integrate Model Service for Generation Parameters (AC: 2, 4)
  - [x] Implement method to call ModelService.getGenerationParameters() with user preferences [Source: Story 2.1]
  - [x] Pass user preferences (difficultyPreference, preferredFormats) to model service [Source: Story AC 5]
  - [x] Receive ModelParameters from model service (lexicalNoveltyBudget, constructionSets, variationPattern, comprehensibilityTarget, semanticStability) [Source: Story 2.1]
  - [x] Store model parameters for use in prompt construction and content metadata [Source: Story AC 12]
  - [x] Handle model service errors gracefully (fallback to default parameters if model service unavailable) [Source: Story AC 13]

- [x] Task 3: Implement Prompt Engineering System (AC: 3, 7, 8)
  - [x] Create prompt template system for different content formats (narrative, podcast, educational) [Source: Story AC 8]
  - [x] Implement meaning-first prompt construction (prioritizes semantic grounding, narrative context) [Source: docs/brief-v2-mvp.md]
  - [x] Implement meaning anchoring in prompts (language coupled to situational context, narrative coherence) [Source: docs/brief-v2-mvp.md]
  - [x] Implement controlled variation specifications in prompts (same meaning, different phrasings) [Source: docs/brief-v2-mvp.md]
  - [x] Configure prompts for Italian language output (explicit language specification, Italian cultural context) [Source: Story AC 7]
  - [x] Create prompt builder that incorporates model parameters (lexical sets, construction sets, variation patterns) [Source: Story AC 3, 4]
  - [x] Implement format-specific prompt templates (narrative/story, podcast-style, educational/explanatory) [Source: Story AC 8]
  - [x] Document prompt engineering approach and model principle alignment [Source: Story AC 3]

- [x] Task 4: Implement Content Format Selection (AC: 8)
  - [x] Create format selection logic (use user preferences, model recommendations, or randomization) [Source: Story AC 8]
  - [x] Implement narrative/story format template with model-driven parameters [Source: Story AC 8]
  - [x] Implement podcast-style format template with conversational, informative tone [Source: Story AC 8]
  - [x] Implement educational/explanatory format template with tutorial-style structure [Source: Story AC 8]
  - [x] Ensure format selection integrates with model service recommendations (if available) [Source: Story 2.1]
  - [x] Store format type in generated content metadata [Source: Story AC 12]

- [x] Task 5: Implement Gemini API Integration (AC: 1, 6, 11)
  - [x] Use Gemini API client service from Story 2.2 for API calls [Source: Story 2.2]
  - [x] Construct Gemini API request with model-driven prompts [Source: Story AC 1]
  - [x] Configure request parameters (temperature, maxTokens) based on model parameters [Source: Story AC 4]
  - [x] Implement async/await pattern for non-blocking generation [Source: Story AC 11]
  - [x] Set timeout to 10 seconds for API calls [Source: Story AC 11]
  - [x] Handle rate limiting using API integration service layer [Source: Story AC 6, Story 2.2]
  - [x] Track API usage for quota management [Source: Story AC 6]

- [x] Task 6: Implement Content Quality Validation (AC: 9, 10, 14)
  - [x] Create content validation utility (`apps/api/src/utils/contentValidator.ts`) [Source: Story AC 14]
  - [x] Implement non-empty text validation [Source: Story AC 14]
  - [x] Implement minimum length validation (e.g., minimum 100 words for narrative, 50 words for podcast/educational) [Source: Story AC 14]
  - [x] Implement Italian language detection (basic validation, not full NLP) [Source: Story AC 14]
  - [x] Implement model criteria validation (check if content aligns with model principles) [Source: Story AC 9, 14]
  - [x] Implement grammatical coherence check (basic validation, not full grammar checking) [Source: Story AC 10]
  - [x] Return validation errors with actionable messages [Source: Story AC 14]
  - [x] Retry generation if validation fails (up to 2 retries) [Source: Story AC 14]

- [x] Task 7: Implement Content Metadata Generation (AC: 12)
  - [x] Extract text content from Gemini API response [Source: Story AC 12]
  - [x] Calculate word count from generated text [Source: Story AC 12]
  - [x] Estimate duration based on word count (average reading speed for Italian) [Source: Story AC 12]
  - [x] Store format type (narrative, podcast, educational) [Source: Story AC 12]
  - [x] Store difficulty level (lexical-heavy or discourse-heavy) from model parameters [Source: Story AC 12]
  - [x] Store generation timestamp [Source: Story AC 12]
  - [x] Store model parameters used for generation [Source: Story AC 12]
  - [x] Create structured Content object with all metadata [Source: docs/architecture/data-models.md]

- [x] Task 8: Implement Error Handling and Fallbacks (AC: 6, 13)
  - [x] Handle network errors (timeout, connection failure) with retry logic [Source: Story AC 13]
  - [x] Handle API errors (authentication, rate limits, API errors) with appropriate error messages [Source: Story AC 13]
  - [x] Handle timeout errors (10 second timeout exceeded) with user-friendly message [Source: Story AC 13]
  - [x] Implement fallback to default parameters if model service unavailable [Source: Story AC 13]
  - [x] Return structured error responses with error type and message [Source: Story AC 13]
  - [x] Log errors with context for debugging [Source: Story AC 13]
  - [x] Use API integration service layer error handling [Source: Story 2.2]

- [x] Task 9: Implement On-Demand Generation (AC: 15)
  - [x] Ensure each generation request creates fresh content (no caching or pre-generation) [Source: Story AC 15]
  - [x] Verify content is generated according to current model specifications [Source: Story AC 15]
  - [x] Ensure no content pool or pre-generated content is used [Source: Story AC 15]
  - [x] Document on-demand generation approach [Source: Story AC 15]

- [x] Task 10: Create Content Generation API Route (AC: 1, 2, 5, 12)
  - [x] Create or update `/api/content/generate` route in backend API [Source: docs/architecture/api-specification.md]
  - [x] Implement POST handler that accepts sessionId, userPreferences, adaptationSignals, continuityContext [Source: docs/architecture/api-specification.md]
  - [x] Call content generation service with request parameters [Source: Story AC 1, 2, 5]
  - [x] Return 202 Accepted immediately with generationId [Source: docs/architecture/api-specification.md]
  - [x] Return generation status and estimated completion time [Source: docs/architecture/api-specification.md]
  - [x] Handle errors and return appropriate HTTP status codes [Source: Story AC 13]
  - [x] Integrate with content generation pipeline (Story 2.5 will handle TTS and storage) [Source: Story AC 12]

- [x] Task 11: Create Unit Tests (AC: 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15)
  - [x] Create unit tests for content generation service (`apps/api/tests/services/contentGeneration.test.ts`) [Source: Story AC 1-15]
  - [x] Test model service integration (mock ModelService calls) [Source: Story AC 2, 4]
  - [x] Test prompt engineering with different model parameters [Source: Story AC 3, 7]
  - [x] Test format selection logic [Source: Story AC 8]
  - [x] Test Gemini API integration (mock API client) [Source: Story AC 1, 6]
  - [x] Test content validation (non-empty, minimum length, Italian detection) [Source: Story AC 14]
  - [x] Test error handling scenarios (network errors, API errors, timeouts) [Source: Story AC 13]
  - [x] Test on-demand generation (verify fresh content each time) [Source: Story AC 15]
  - [x] Test metadata generation [Source: Story AC 12]
  - [x] Use Vitest for testing framework [Source: docs/architecture/tech-stack.md]
  - [x] Ensure all tests pass before marking story complete [Source: Story AC 1-15]

## Dev Notes

### Previous Story Insights

**From Story 2.1 (Foundation Model Service Implementation):**
- Model service is implemented with `getGenerationParameters()` method
- Model service provides ModelParameters interface with: lexicalNoveltyBudget, constructionSets, variationPattern, comprehensibilityTarget, semanticStability
- Model service implements core model principles (meaning-first, comprehensibility before correctness, variation is essential)
- Model service is computationally efficient (< 100ms per request)
- Model service API route exists at `/api/model/adaptation` for adaptation recommendations

**From Story 2.2 (External API Integration Setup):**
- Gemini API client service exists at `apps/api/src/services/geminiClient.service.ts`
- API integration service layer exists at `apps/api/src/services/apiIntegration.service.ts`
- Error handling infrastructure is in place (NetworkError, AuthenticationError, RateLimitError, ApiError)
- Rate limit tracking utility exists at `apps/api/src/utils/rateLimitTracker.ts`
- API clients provide consistent error handling interface
- Health check methods are available for all services

**From Story 1.8 (Continuous Content Scrolling & Temporary Storage):**
- Content generation API endpoint `/api/content/generate` is expected by frontend
- Frontend uses polling or webhook for async generation status
- Content interface expects: id, title, textContent, audioUrl, format, difficulty, duration, modelParameters, sessionId
- SessionContext stores content with metadata including modelParameters field

**Key Integration Points:**
- Content generation service must call ModelService.getGenerationParameters() before generating content
- Content generation service must use Gemini API client from Story 2.2
- Content generation service must integrate with content generation pipeline (Story 2.5 will handle TTS and storage)
- Generated content must follow model principles (meaning-first, comprehensibility, variation)
- Error handling must use API integration service layer for consistency

### Data Models

**Content Interface:**
- `id`: string - Unique content identifier [Source: docs/architecture/data-models.md]
- `title`: string - Content title/name [Source: docs/architecture/data-models.md]
- `textContent`: string - Original generated Italian text [Source: docs/architecture/data-models.md]
- `format`: 'narrative' | 'podcast' | 'educational' - Content format type [Source: docs/architecture/data-models.md]
- `difficulty`: 'lexical-heavy' | 'discourse-heavy' - Model-informed difficulty level [Source: docs/architecture/data-models.md]
- `duration`: number - Estimated audio duration in seconds [Source: docs/architecture/data-models.md]
- `wordCount`: number - Word count in text [Source: docs/architecture/data-models.md]
- `modelParameters`: ModelParameters - Model service parameters used for generation [Source: docs/architecture/data-models.md]
- `generatedAt`: Date - Generation timestamp [Source: docs/architecture/data-models.md]
- `sessionId`: string - Session identifier [Source: docs/architecture/data-models.md]

**ModelParameters Interface:**
- `lexicalNoveltyBudget`: number - Rate of new vocabulary introduction [Source: Story 2.1]
- `constructionSets`: string[] - Grammatical patterns for content generation [Source: Story 2.1]
- `variationPattern`: string - Pattern specification for controlled variation [Source: Story 2.1]
- `comprehensibilityTarget`: number - Target comprehensibility score (0-1) [Source: Story 2.1]
- `semanticStability`: number - Semantic stability requirement for meaning anchoring [Source: Story 2.1]

**UserPreferences Interface:**
- `difficultyPreference`: 'beginner' | 'intermediate' | 'advanced' - User-selected difficulty [Source: docs/architecture/data-models.md]
- `preferredFormats`: ('narrative' | 'podcast' | 'educational')[] - Format preferences [Source: docs/architecture/data-models.md]
- `preferredGenres`: string[] - Genre preferences (for narratives) [Source: docs/architecture/data-models.md]

### API Specifications

**Content Generation Endpoint:**
- POST `/api/content/generate` - Generate new Italian audio content [Source: docs/architecture/api-specification.md]
- Request body: `{ sessionId: string, userPreferences?: UserPreferences, adaptationSignals?: object, continuityContext?: object, webhookUrl?: string }` [Source: docs/architecture/api-specification.md]
- Response (202 Accepted): `{ generationId: string, status: 'generating' | 'processing' | 'completed' | 'failed', estimatedCompletionTime?: number, webhookRegistered?: boolean }` [Source: docs/architecture/api-specification.md]
- Note: API returns 202 Accepted immediately, content available via polling or webhook [Source: docs/architecture/api-specification.md]

**Gemini API Integration:**
- Endpoint: `POST /v1beta/models/gemini-1.5-pro:generateContent` [Source: docs/architecture/external-apis.md]
- Authentication: API key in `x-goog-api-key` header [Source: docs/architecture/external-apis.md]
- Request body: `{ contents: [{ parts: [{ text: string }] }], generationConfig?: { temperature?: number, maxOutputTokens?: number } }` [Source: docs/architecture/external-apis.md]
- Response: `{ candidates: [{ content: { parts: [{ text: string }] } }] }` [Source: docs/architecture/external-apis.md]

### File Locations

**Service Files:**
- Content generation service: `apps/api/src/services/contentGeneration.service.ts` [Source: docs/architecture/unified-project-structure.md]
- Gemini API client: `apps/api/src/services/geminiClient.service.ts` (from Story 2.2)
- API integration service: `apps/api/src/services/apiIntegration.service.ts` (from Story 2.2)

**Utility Files:**
- Content validator: `apps/api/src/utils/contentValidator.ts` [Source: Story AC 14]
- Rate limit tracker: `apps/api/src/utils/rateLimitTracker.ts` (from Story 2.2)

**Route Files:**
- Content generation route: `apps/api/src/routes/content.routes.ts` (may need to create or update) [Source: docs/architecture/unified-project-structure.md]

**Test Files:**
- Unit tests: `apps/api/tests/services/contentGeneration.test.ts` [Source: docs/architecture/unified-project-structure.md]

### Technical Constraints

- **TypeScript Version:** Must use TypeScript 5.x [Source: docs/architecture/tech-stack.md]
- **Package Manager:** Must use pnpm (required for monorepo consistency) [Source: docs/architecture/tech-stack.md]
- **Backend Framework:** Express 4.x [Source: docs/architecture/tech-stack.md]
- **Testing Framework:** Vitest + Supertest [Source: docs/architecture/tech-stack.md]
- **API Client:** Must use Gemini API client from Story 2.2 [Source: Story 2.2]
- **Model Service:** Must use ModelService from `@packages/model-service` package [Source: Story 2.1]
- **Generation Time:** Must complete within 5-10 seconds (non-blocking) [Source: Story AC 11]
- **Error Handling:** Must use API integration service layer for consistent error handling [Source: Story 2.2]

### Foundation Model Principles

**Core Model Principles for Content Generation:**
1. **Meaning-first approach:** Prioritizes semantic grounding over grammatical complexity [Source: docs/brief-v2-mvp.md]
2. **Comprehensibility before correctness:** Gates by semantic access, not grammar mastery [Source: docs/brief-v2-mvp.md]
3. **Variation is essential:** Controlled variation around stable meaning drives abstraction [Source: docs/brief-v2-mvp.md]
4. **Meaning anchoring:** Language must be coupled to something other than language (narrative context, situational intent) [Source: docs/brief-v2-mvp.md]
5. **Statistical abstraction:** Generalization requires contrast across exemplars [Source: docs/brief-v2-mvp.md]

**Prompt Engineering Approach:**
- Prompts must prioritize meaning-first (semantic grounding, narrative coherence)
- Prompts must specify controlled variation (same meaning, different phrasings)
- Prompts must anchor language to non-linguistic context (situational intent, narrative scenes)
- Prompts must configure comprehensibility (appropriate difficulty, known material for inference)
- Prompts must specify Italian language output with cultural authenticity

### Project Structure Notes

- Content generation service should be in `apps/api/src/services/` [Source: docs/architecture/unified-project-structure.md]
- Content generation service imports ModelService from `@packages/model-service` package [Source: Story 2.1]
- Content generation service uses Gemini API client from Story 2.2 [Source: Story 2.2]
- Content generation service integrates with content generation pipeline (Story 2.5) [Source: Story AC 12]
- Generated content must be stored in Content format for pipeline processing [Source: docs/architecture/data-models.md]

### Testing

**Testing Standards:**
- Testing framework: Vitest + Supertest [Source: docs/architecture/tech-stack.md]
- Test file locations: `apps/api/tests/services/` [Source: docs/architecture/unified-project-structure.md]
- Test coverage: Unit tests for content generation service, model service integration, prompt engineering, validation [Source: Story AC 1-15]
- Mock implementations: Mock ModelService, mock Gemini API client for unit tests [Source: Story AC 1-15]

**Testing Approach:**
- Unit tests with mocked ModelService and Gemini API client
- Test prompt engineering with various model parameters
- Test format selection logic
- Test content validation (non-empty, minimum length, Italian detection)
- Test error handling scenarios (network errors, API errors, timeouts)
- Test on-demand generation (verify fresh content each time)
- Test metadata generation (word count, duration estimation)
- Performance tests to verify generation completes within 5-10 seconds

**Test Data:**
- Create mock ModelParameters for testing prompt construction
- Create mock Gemini API responses for testing content extraction
- Create test user preferences for testing format selection
- Use simple validation test cases for content validation

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2026-01-07 | 1.0 | Initial story draft created | Scrum Master |
| 2026-01-07 | 1.1 | Story implementation completed - all tasks done | Dev Agent |

## Dev Agent Record

### Agent Model Used
- Cursor Dev Agent

### File List (added/modified)
- apps/api/src/services/contentGeneration.service.ts (added)
- apps/api/src/utils/promptBuilder.ts (added)
- apps/api/src/utils/contentValidator.ts (added)
- apps/api/src/routes/content.routes.ts (added)
- apps/api/src/server.ts (modified - added content routes)
- apps/api/tests/services/contentGeneration.test.ts (added)
- apps/api/tests/utils/contentValidator.test.ts (added)
- docs/stories/2.3.model-driven-ai-text-generation-service.story.md (status, checkboxes, record)

### Debug Log References
- See `.ai/debug-log.md` for step-by-step execution notes (if present).

### Completion Notes
- All 11 tasks completed successfully
- Content generation service fully implemented with model-driven parameters
- Prompt engineering system implements all model principles (meaning-first, comprehensibility, variation, semantic anchoring)
- Content validation with Italian language detection and model criteria checks
- Comprehensive error handling with fallbacks and retry logic
- On-demand generation ensures fresh content for each request
- API route `/api/content/generate` implemented and integrated
- All unit tests passing (16 tests for content generation service, 11 tests for content validator)
- Service integrates with ModelService from Story 2.1 and Gemini API client from Story 2.2
- Ready for integration with TTS and storage pipeline (Story 2.5)

## QA Results
_To be populated by QA Agent_
